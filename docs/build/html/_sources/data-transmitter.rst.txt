Entiendo `data_transmitter_main.c`
==================================

En esta página se describe la composición y definición del script ``data_transmitter_main.c``. Este script es utilizado para la transmisión personalizada de un string en una comunicación V2X. Para más información leer el apartado :doc:`basic`.

Este código está escrito es lenguaje ``C``.

Cabecera
--------

En primer lugar se incluyen directivas de pre-procesado para:

- Extensiones especificas de GNU (más allá de POSIX)
- Hilos
- Señales
- Flujos de entrada y salida
- Cadenas de caracteres
- Constantes y funciones de bajo nivel
- Funciones estándar de propósito general
- Manipulación y medición del tiempo
- Funciones específicas para manejo del tiempo

.. code:: c

    #define _GNU_SOURCE
    #include <pthread.h>
    #include <signal.h>
    #include <stdio.h>
    #include <string.h>
    #include <unistd.h>
    #include <stdlib.h>
    #include <time.h>
    #include <sys/time.h>

Después, incluye dos archivos de cabecera personalizados. Estos permite hacer uso de la API del SDK de los módulos Unex utilizados en este proyecto.

.. code:: c

    #include "us_caster_service.h"
    #include "error_code_user.h"

A continuación, encontramos la definición de macros.

.. code:: c
    
    #define MAX_BUFFER_SIZE 1024

El código define varios tipos de datos para mejorar la legibilidad y organización del script. Entre ellos se encuentran:

- Tipos de datos de aplicación: usados para controlar el estado de la aplicación.
- Tipos de datos de hilo: determinan el rol de transmisión o recepción, activando diferentes partes del código según el caso.

.. code:: c

    typedef enum app_state_type {
        APP_STATE_DESTROY = 0,
        APP_STATE_INITIAL = 1,
        APP_STATE_READY = 2,
    } app_state_type_t;

    typedef enum app_thread_type {
        APP_THREAD_TX = 0,
        APP_THREAD_RX = 1
    } app_thread_type_t;


La sección de cabecera concluye con la declaración de varias variables globales:

- Inicialización de un tipo de dato de aplicación
- Un ``caster_handler`` inicializado con un valor no valido.
- Un puntero ``char`` que apunta a ID del caster.

.. code:: c

    static uint8_t app_state = APP_STATE_INITIAL;
    static caster_handler_t caster_handler = INVALID_CASTER_HANDLER;
    static char *caster_rx_id;

Funciones
---------

Leer input del usuario
^^^^^^^^^^^^^^^^^^^^^^

La función ``read_user_input()`` recibe como parámetros:

- Un puntero ``char`` que apunta al comienzo del buffer con el contenido proporcionado.
- Longitud máxima.

El funcionamiento es el siguiente:

- Se le solicita un input de tipo ``string`` y comprueba que no este a ``NULL``.
    - En caso de ``NULL``, genera un error y termina la ejecución del programa.
- Si el ``string`` proporcionado contiene el carácter ``\n`` , se elimina.
    - En consecuencia, se decrementa su longitud ``input_length``.

.. code:: c

    int read_user_input(char *input_buffer, size_t max_length)
    {
        printf("Enter a string: ");
        if (fgets(input_buffer, max_length, stdin) == NULL) {
            fprintf(stderr, "Error reading input.\n");
            return -1;
        }

        // Remove trailing newline if present
        size_t input_length = strlen(input_buffer);
        if (input_length > 0 && input_buffer[input_length - 1] == '\n') {
            input_buffer[input_length - 1] = '\0';
            input_length--;
        }

        return input_length;
    }

Transmisión de la información
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

La función ``transmit_data()`` es la que función que, haciendo uso de la API del SDK de los módulos Unex, envía la información. Concretamente, hace uso de la función ``us_caster_tx()`` para transmitir la información.

Recibe como parámetros un puntero a ``data``.

El funcionamiento es el siguiente:

- Obtiene la longitud de la cadena a transmitir
- Desplaza todos los caracteres una posición a la derecha
- Añade información sobre ID del caster
    - Un byte inicial al principio de ``data``.
    - Un símbolo ``%`` al final de ``data``. Para ello, desplazada una posición a la derecha el símbolo de final de `string` (`\0`).
- Hace uso de ``us_caster_tx()``
    - En caso de error, notifica el estado por pantalla y termina la ejecución del programa.
    - En ausencia de error, notifica la transmisión de ``data`` por pantalla.
- Por último, bloquea la ejecución del programa durante 100 ms, para dar tiempo al receptor a procesar la información

Si todo se ha ejecutado correctamente, se vuelve un ``0``.

.. code:: c

    int transmit_data(char *data)
    {
        int len = strlen(data); // Obtener la longitud actual de la cadena
        
        // Desplazar todos los caracteres a la derecha para hacer espacio para el nuevo carácter
        for (int i = len; i >= 0; i--) {
            data[i + 1] = data[i];
        }

        // Añadir el id del caster
        data[0] = caster_rx_id[0];
        data[strlen(data)] = '%';
        data[strlen(data) + 1] = '\0';
        
        int ret = us_caster_tx(caster_handler, NULL, (uint8_t *)data, strlen(data)); //API SDK envio de data
        if (!IS_SUCCESS(ret)) {
            printf("Error transmitting data: %d\n", ret);
            return -1;
        }
        printf("Character transmitted: %s\n", data);

        usleep(100000); // Sleep for 100 ms between transmissions

        return 0;
    }

Función de recepción de señales
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

La función ``app_signal_handler()``  es la función que se encarga de manejar las señales del programa. En concreto, las señales ``SIGINT`` y ``SIGTERM``. La primera de ellas hace referencia a una señal típicamente generada cuando el usuario pulsa ``Ctrl+C``. La segunda, es la señal estándar de solicitud de finalización del programa.

Cuando se recibe alguna de estas señales, el programa notifica que procede a la finalización y cambia el estado a ``APP_STATE_DESTROY``.

.. code:: c

    void app_signal_handler(int sig_num)
    {
        if (sig_num == SIGINT || sig_num == SIGTERM) {
            printf("Received signal %d, shutting down...\n", sig_num);
            app_state = APP_STATE_DESTROY;
        }
    }